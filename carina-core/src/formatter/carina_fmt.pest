// Carina DSL Grammar for Formatting
// Unlike the semantic parser, this grammar captures whitespace and comments

// Entry point - captures everything including trivia
file = { SOI ~ file_content* ~ EOI }
file_content = _{ trivia | statement }

// Trivia: whitespace and comments that we want to preserve
trivia = { ws | comment | newline }
ws = @{ (" " | "\t")+ }
newline = @{ NEWLINE }
comment = @{ "#" ~ (!NEWLINE ~ ANY)* }

statement = { import_stmt | backend_block | provider_block | input_block | output_block | let_binding | module_call | anonymous_resource }

// Import statement: import "./path/to/module.crn" as name
import_stmt = {
    kw_import ~ trivia+ ~ string ~ trivia+ ~ kw_as ~ trivia+ ~ identifier
}

// Backend block: backend s3 { ... }
backend_block = {
    kw_backend ~ trivia+ ~ identifier ~ trivia* ~ open_brace ~ block_content* ~ close_brace
}

// Anonymous resource: aws.s3.bucket { ... }
anonymous_resource = {
    namespaced_id ~ trivia* ~ open_brace ~ block_content* ~ close_brace
}

// Module call: module_name { key = value, ... }
module_call = {
    identifier ~ trivia* ~ open_brace ~ block_content* ~ close_brace
}

// Provider block: provider aws { ... }
provider_block = {
    kw_provider ~ trivia+ ~ identifier ~ trivia* ~ open_brace ~ block_content* ~ close_brace
}

// Input block: input { name: type, name: type = default }
input_block = {
    kw_input ~ trivia* ~ open_brace ~ input_block_content* ~ close_brace
}

input_block_content = _{ trivia | input_param }

// Input parameter: name: type or name: type = default
input_param = {
    identifier ~ trivia* ~ colon ~ trivia* ~ type_expr ~ (trivia* ~ equals ~ trivia* ~ expression)?
}

// Output block: output { name: type = value }
output_block = {
    kw_output ~ trivia* ~ open_brace ~ output_block_content* ~ close_brace
}

output_block_content = _{ trivia | output_param }

// Output parameter: name: type = value
output_param = {
    identifier ~ trivia* ~ colon ~ trivia* ~ type_expr ~ trivia* ~ equals ~ trivia* ~ expression
}

// Type expression: string, bool, int, cidr, list(type), map(type), ref(aws.resource)
type_expr = {
    type_ref | type_list | type_map | type_primitive
}

type_primitive = @{ "string" | "bool" | "int" | "float" | "cidr" }

type_list = { kw_list ~ trivia* ~ open_paren ~ trivia* ~ type_expr ~ trivia* ~ close_paren }

type_map = { kw_map ~ trivia* ~ open_paren ~ trivia* ~ type_expr ~ trivia* ~ close_paren }

type_ref = { kw_ref ~ trivia* ~ open_paren ~ trivia* ~ namespaced_id ~ trivia* ~ close_paren }

// Variable/resource definition: let name = value
let_binding = {
    kw_let ~ trivia+ ~ identifier ~ trivia* ~ equals ~ trivia* ~ expression
}

// Block content: attributes, trivia, or nested elements
block_content = _{ trivia | attribute }

// Attribute: key = value
attribute = { identifier ~ trivia* ~ equals ~ trivia* ~ expression }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Namespaced identifier: aws.s3.bucket, aws.Region.ap_northeast_1
namespaced_id = @{ identifier ~ ("." ~ identifier)+ }

// Expression
expression = { pipe_expr }

// Pipe operator: value |> func |> func
pipe_expr = { primary ~ (trivia* ~ pipe_op ~ trivia* ~ function_call)* }

// Function call: func(args)
function_call = {
    identifier ~ open_paren ~ (trivia* ~ expression ~ (trivia* ~ comma ~ trivia* ~ expression)*)? ~ trivia* ~ close_paren
}

// Primary value
primary = {
    env_var
  | resource_expr
  | list
  | map
  | namespaced_id
  | boolean
  | float
  | number
  | string
  | variable_ref
  | open_paren ~ trivia* ~ expression ~ trivia* ~ close_paren
}

// List: [item1, item2, ...]
list = {
    open_bracket ~ trivia* ~ (expression ~ (trivia* ~ comma ~ trivia* ~ expression)*)? ~ trivia* ~ comma? ~ trivia* ~ close_bracket
}

// Map: { key = value, ... } (commas are optional)
map = {
    open_brace ~ map_content* ~ close_brace
}

map_content = _{ trivia | map_entry }

// Map entry: key = value (with optional trailing comma)
map_entry = { identifier ~ trivia* ~ equals ~ trivia* ~ expression ~ trivia* ~ comma? }

// Environment variable: env("VAR_NAME")
env_var = { kw_env ~ open_paren ~ trivia* ~ string ~ trivia* ~ close_paren }

// Resource expression: aws.s3.bucket { ... }
resource_expr = {
    namespaced_id ~ trivia* ~ open_brace ~ block_content* ~ close_brace
}

// Variable reference (with optional member access: bucket.name)
variable_ref = { identifier ~ ("." ~ identifier)? }

// Literals
boolean = { "true" | "false" }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = ${ "\"" ~ inner_string ~ "\"" }
inner_string = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
}

// Tokens (for easier identification in CST)
open_brace = { "{" }
close_brace = { "}" }
open_bracket = { "[" }
close_bracket = { "]" }
open_paren = { "(" }
close_paren = { ")" }
equals = { "=" }
colon = { ":" }
comma = { "," }
pipe_op = { "|>" }

// Keywords
kw_provider = { "provider" }
kw_backend = { "backend" }
kw_import = { "import" }
kw_as = { "as" }
kw_let = { "let" }
kw_env = { "env" }
kw_input = { "input" }
kw_output = { "output" }
kw_ref = { "ref" }
kw_list = { "list" }
kw_map = { "map" }
